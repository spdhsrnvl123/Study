# Tailwind CSS + shadcn/ui + Zustand 학습 정리

> React 프로젝트에서 Tailwind CSS, shadcn/ui, Zustand를 활용한 실습 가이드

## 목차
- [Tailwind CSS 기본](#tailwind-css-기본)
- [shadcn/ui](#shadcnui)
- [Zustand 상태 관리](#zustand-상태-관리)
- [실습 예제](#실습-예제)

---

## Tailwind CSS 기본

### Spacing 단위
기본 spacing 단위는 **4px**입니다.
```jsx
// w-<number> → width: calc(var(--spacing) * <number>);- spacing(간격단위) = 기본 4px
<div className="w-2">    // 8px (2 × 4px)
<div className="w-full"> // 100%

// h-<number> → height: calc(var(--spacing) * <number>);- spacing(간격단위) = 기본 4px
<div className="h-2">    // 8px (2 × 4px)

// p-<number> → padding: calc(var(--spacing) * <number>);- spacing(간격단위) = 기본 4px
<div className="p-4">    // 16px (4 × 4px)
```

### Flexbox

#### flex-1
자식 요소 중 최대 너비로 증가합니다.
```jsx
<div className="flex flex-row items-start justify-evenly">
  <div className="h-10 w-10 border">1</div>
  <div className="h-20 w-10 flex-1 border">2</div>  {/* 최대 너비 */}
  <div className="h-30 w-10 border">3</div>
</div>
```

#### basis
`flex-basis` 속성을 설정합니다.
```jsx
// basis-1/3 → flex-basis: 33.33%
<CarouselItem className="basis-1/3">1</CarouselItem>
```

---

## shadcn/ui

### 특징
- 필요한 컴포넌트만 **선택적 설치** (MUI, Bootstrap과 다름)
- 전체 패키지 설치 X → **프로젝트 용량 경량화**
- Tailwind와 완벽 통합

### 설치 후 생성 파일

#### components.json
컴포넌트 설치 방식을 설정하는 파일입니다.
색상 테마(예: Neutral) 선택 시 `index.css`에 자동 반영됩니다.

#### lib/utils.ts
조건부 클래스를 유동적으로 설정하는 `cn` 헬퍼 함수를 제공합니다.
```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

### Compound Component Pattern

여러 컴포넌트를 조합하여 하나의 기능을 구성하는 패턴입니다.
```jsx
<Carousel>
  <CarouselContent>
    <CarouselItem>...</CarouselItem>
    <CarouselItem>...</CarouselItem>
  </CarouselContent>
  <CarouselPrevious />
  <CarouselNext />
</Carousel>
```

### asChild Props

`asChild`를 사용하면 자식 컴포넌트를 트리거로 사용할 수 있습니다.
```jsx
{/* asChild 사용: Button 클릭 시 Popover 열림 */}
<Popover>
  <PopoverTrigger asChild>
    <Button>Open</Button>
  </PopoverTrigger>
  <PopoverContent>Content!</PopoverContent>
</Popover>

{/* asChild 미사용: 각각 독립적으로 동작 */}
```

### open Props

Dialog의 열림/닫힘 상태를 직접 제어할 수 있습니다.
```jsx
<Dialog open={true}>  {/* 항상 열림 */}
  <DialogTrigger>Open Dialog</DialogTrigger>
  <DialogContent>
    <DialogTitle>Title</DialogTitle>
    <div>Body</div>
  </DialogContent>
</Dialog>
```

---

## Zustand 상태 관리

### Context API vs Zustand

| 항목 | Context API | Zustand |
|------|-------------|---------|
| 용도 | Props Drilling 해결 | 전역 상태 관리 |
| 문제점 | 하위 컴포넌트 전체 리렌더링 | - |
| 적합한 경우 | 국소적 데이터 공유 | 범용적 전역 상태 |

### Zustand 장점
- 많은 사용자
- 매우 가벼운 용량
- 직관적이고 배우기 쉬움

---

## 실습 예제

### 1단계: 기본 Store 생성
```typescript
// store/count.ts
import { create } from "zustand";

type Store = {
  count: number;
  increase: () => void;
  decrease: () => void;
}

export const useCountStore = create<Store>((set, get) => ({
  count: 0,
  increase: () => {
    // 방법1: get() 사용
    // const count = get().count;
    // set({ count: count + 1 })
    
    // 방법2: set 콜백 (권장)
    set((store) => ({ 
      count: store.count + 1 
    }));
  },
  decrease: () => {
    set((store) => ({ 
      count: store.count - 1 
    }))
  },
}));
```

### 2단계: 컴포넌트에서 사용
```tsx
// pages/CounterPage.tsx
import { Button } from "@/components/ui/button";
import { useCountStore } from "@/store/count";

export default function CounterPage() {
  const { count, increase, decrease } = useCountStore();

  return (
    <div>
      <h1 className="text-2xl font-bold">Counter Page</h1>
      <div>{count}</div>
      <div>
        <Button onClick={decrease}>-</Button>
        <Button onClick={increase}>+</Button>
      </div>
    </div>
  );
}
```

### 3단계: 리렌더링 최적화

#### 문제 상황
```tsx
// ❌ store 전체 구조분해 → count 변경 시 리렌더링 발생
const { decrease, increase } = useCountStore();
```

#### 해결 방법 1: Selector 함수
```tsx
// ✅ 필요한 값만 선택 → 리렌더링 방지
const increase = useCountStore((store) => store.increase);
const decrease = useCountStore((store) => store.decrease);
```

#### 해결 방법 2: Actions 그룹화
```typescript
// store/count.ts
type Store = {
  count: number;
  actions: {  // actions로 그룹화
    increase: () => void;
    decrease: () => void;
  };
};

export const useCountStore = create<Store>((set) => ({
  count: 0,
  actions: {
    increase: () => set((store) => ({ count: store.count + 1 })),
    decrease: () => set((store) => ({ count: store.count - 1 })),
  },
}));
```
```tsx
// 사용
const { increase, decrease } = useCountStore((store) => store.actions);
```

### 4단계: 커스텀 훅 패턴 (권장)

#### 왜 필요한가?
- 함수명 변경 시 유지보수 편리
- 여러 컴포넌트에서 사용 시 일괄 수정 가능
```typescript
// store/count.ts
export const useCountStore = create<Store>(/* ... */);

// 커스텀 훅
export const useCount = () => {
  return useCountStore((store) => store.count);
}

export const useIncreaseCount = () => {
  return useCountStore((store) => store.actions.increase);
}

export const useDecreaseCount = () => {
  return useCountStore((store) => store.actions.decrease);
}
```
```tsx
// components/Controller.tsx
import { useDecreaseCount, useIncreaseCount } from "@/store/count";
import { Button } from "../ui/button";

export default function Controller() {
  const increase = useIncreaseCount();
  const decrease = useDecreaseCount();
  
  return (
    <div>
      <Button onClick={decrease}>-</Button>
      <Button onClick={increase}>+</Button>
    </div>
  );
}
```

---

## Zustand Middleware

### 종류
| Middleware | 설명 |
|-----------|------|
| **combine** | Store 타입 자동 추론 |
| **immer** | 상태 업데이트 편리화 |
| **subscribeWithSelector** | 특정 값 변화 감지 |
| **persist** | 로컬/세션 스토리지 저장 |
| **devtools** | 개발자 도구 연동 |

### combine 사용

타입을 자동으로 추론해줍니다.
```typescript
import { create } from "zustand";
import { combine } from "zustand/middleware";

export const useCountStore = create(
  combine(
    { count: 0 },  // state (타입 자동 추론)
    (set, get) => ({
      actions: {
        increaseOne: () => {
          set((state) => ({ 
            count: state.count + 1 
          }));
        },
        decreaseOne: () => {
          set((state) => ({ 
            count: state.count - 1 
          }));
        },
      },
    })
  )
);
```

#### ⚠️ combine 주의사항
- `set`의 첫 번째 인자는 **state만 포함** (actions 제외)
- 타입 추론만 제공, 런타임 에러는 발생하지 않음
- 매개변수명은 `store`보다 `state`가 더 명확

### immer 사용

불변성 걱정 없이 상태를 직접 수정할 수 있습니다.
```typescript
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { combine } from "zustand/middleware";

export const useCountStore = create(
  immer(
    combine({ count: 0 }, (set) => ({
      actions: {
        increaseOne: () => {
          // ✅ 불변성 걱정 없이 직접 수정
          set((state) => {
            state.count += 1;
          });
        },
        decreaseOne: () => {
          set((state) => {
            state.count -= 1;
          });
        },
      },
    }))
  )
);
```

---

## 핵심 정리

### Tailwind
- `w-4` = 16px (4 × 4px)
- `flex-1` = 최대 너비 차지

### shadcn/ui
- 필요한 컴포넌트만 설치 → 경량
- `cn()` 함수로 조건부 클래스 적용
- `asChild` Props로 자식을 트리거로 사용

### Zustand
- Selector 함수로 불필요한 리렌더링 방지
- Actions 그룹화 + 커스텀 훅으로 유지보수성 향상
- Middleware로 개발 편의성 증대
