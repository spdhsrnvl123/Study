tailwindcss

w-<number> → width: calc(var(--spacing) * <number>);
- spacing(간격단위) = 기본 4px

ex) class="w-2" → 2 x 4px = 8px

w-full → 100% 설정

h-<number> → height: calc(var(--spacing) * <number>);
- spacing(간격단위) = 기본 4px

p-<number> → padding: calc(var(--spacing) * <number>);
- spacing(간격단위) = 기본 4px

flex-1 자식요소중에 최대너비로 증가
ex)
      {/* 6. Flexbox */}
      <div className="flex flex-row items-start justify-evenly">
        <div className="h-10 w-10 border">1</div>
        <div className="h-20 w-10 flex-1 border">2</div>
        <div className="h-30 w-10 border">3</div>
        <div className="h-40 w-10 border">4</div>
      </div>

shadcn/ui

components.json
shadcn UI에서 제공하는 여러 가지 버튼, 인풋 같은 UI컴포넌트들을 추가 설치할 때 어떤 방식으로 설치할지 결정하는 기준이 된다.
즉, 보통 UI라이브러리들과 다르게 전체 컴포넌트를 한꺼번에 다 일괄적으로 설치하는 방식으로 셋업이 되는게 아니라
필요한 컴포넌트들만 선택적으로 설치하는 방식을 사용한다.

MUI, BOOT는 Input, Button 컴포넌트 등이 일괄적으로 설치된다. 하지만 shadcn은 하나하나 컴포넌트들을 개별적으로
직접 개별 명령어를 통해서 따로 설치를 진행을 해줘야 된다.

즉 shadcn UI를 사용하면 전체 프로젝트의 용량이 가벼워질 수 있는 이점이 있다.

shadcn/ui 설치시 "Which color would you like to use as the base color?" 물어보는데 Neutral값으로
했다면 index.css에 있는 색깔은 Neutral값으로 맞추어진다.

shadcn/ui 셋팅과정을 마치면 lib/utils.ts 파일이 생성된다.

//utils.ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
cn함수는 특정 조건에 따라서 클래스를 유동적으로 설정해줄 때 활용된다.
cn이라는 Tailwind Helper함수도 기본으로 또 제공이 된다.

Compound Component Pattern(합성 컴포넌트 패턴)

<Carousel>
  <CarouselContent>
    <CarouselItem>...</CarouselItem>
    <CarouselItem>...</CarouselItem>
    <CarouselItem>...</CarouselItem>
  </CarouselContent>
  <CarouselPrevious />
  <CarouselNext />
</Carousel>

flex-basis : calc(1/3 * 100%) /* 33.3333%*/
→ basis-1/3
basis는 flex-item 크기를 설정하는것이다.
      <Carousel>
        <CarouselContent>
          <CarouselItem className="basis-1/3">1</CarouselItem>
          <CarouselItem>2</CarouselItem>
          <CarouselItem>3</CarouselItem>
          <CarouselItem>4</CarouselItem>
          <CarouselItem>5</CarouselItem>
        </CarouselContent>
        <CarouselPrevious />
        <CarouselNext />
      </Carousel>


asChild
PopoverTrigger에서 asChild를 사용하면 Button을 클릭했을때 팝 요소가 클릭된다.
asChild를 사용하지 않으면 각각 개별적인 컴포넌트로 동작한다.
      <Popover>
        <PopoverTrigger asChild>
          <Button>Open</Button>
        </PopoverTrigger>
        <PopoverContent>
          Content!
        </PopoverContent>
      </Popover>

open={true}
항상 Dialog를 오픈되게 한다.
활용도는 Dialog를 조작할 수 있다.
      <Dialog open={true}>
        <DialogTrigger>Open Dialog</DialogTrigger>
        <DialogContent>
          <DialogTitle>Title</DialogTitle>
          <div>Body</div>
        </DialogContent>
      </Dialog>


상태관리

ContextAP
전역 상태 관리를 위한 기능이라기 보다는 Props Drilling 이슈를 해결하기 위해 제공되는 기능
전역 상태 관리르 ㄹ위한 기능이라기보다는 Props Drilling 이라는 이슈를 해결하기 위해시 제공이 되는 기능이다.
문제점
상태값이 한 번 업데이트 될 때 마다 컨텍스트 하위의 모든 컴포넌트들이 불필요하게 다 리렌더링 될 수 있다는
치면적인 한계점이 존재한다. 그렇기 때문에 Context API는 보통 완전히 전역적인 데이터를 관리하기 보다는
특정 컴포넌트들끼리만 공유하는 데이터를 다룰 때 더 효과적으로 사용할 수가 있다.

정리
범용적인 전역 상태 관리 보다는 국소적인 데이터 공유를 위해 더 자주 사용된다.

그렇기 때문에 전역적인 상태관리를 하려면 Redux, Recoil, Mobx, Zustand를 사용하는게 일반적이다.

Zustand
1. 많은 사람들이 사용하고 있음
2. 용량이 매우 가벼움
3. 매우 직관적이어서 배우기가 쉬움

기본사용법
//스토어 정의
import { create } from "zustand";

type Store ={
  count: number;
  increase: () => void;
  decrease: () => void;
}

export const useCountStore = create<Store>((set, get) => ({
  count: 0,
  increase: () => {
    // const count = get().count; //get을 따로 불러와서 변수에저장해서 만들 수 있음
    // set({
    //   count: count + 1
    // })//프로퍼티값만 업데이트함 

    //위 방법보다 해당 방법이 get 안불러오고 더 심플
    set((store) => ({ //store자체를 의미함
        count: store.count + 1,
    }));
  },
  decrease: () => {
    set((store)=>({
      count: store.count - 1,
    }))
  },
}));


//사용
import {create} from 'zustand';
→ state, action 함수를 포함하는 객체인 store를 생성

import { Button } from "@/components/ui/button";
import { useCountStore } from "@/store/count";

export default function CounterPage() {
  const { count, increase, decrease } = useCountStore();

  return (
    <div>
      <h1 className="text-2xl font-bold">Counter Page</h1>
      <div>{count}</div>
      <div>
        <Button onClick={decrease}>-</Button>
        <Button onClick={increase}>+</Button>
      </div>
    </div>
  );
}

znstand는 컴포넌트에서 불러온 store값들 중 하나라도 업데이트가 되면, 해당 컴포넌트 자동으로
리렌더링 시킴 

  const { decrease, increase } = useCountStore();
현재 Controller 컴포넌트에서 store객체의 전부를 불러와서 전부 리렌더링 됨


import { useCountStore } from "@/store/count";
import { Button } from "../ui/button";

export default function Controller() {
  const increase  = useCountStore((store)=>store.increase); //셀렉터 함수
  const decrease  = useCountStore((store)=>store.decrease);
  return (
    <div>
      <Button onClick={decrease}>-</Button>
      <Button onClick={increase}>+</Button>
    </div>
  );
}

셀렉터 함수를 통해서 특정값만 불러오면 리렌더링 되지 않는다.
위에 셀렉터함수 두번을 선언하기 싫다면 

import { create } from "zustand";

type Store = {
  count: number;
  actions: {
    increase: () => void;
    decrease: () => void;
  };
};

export const useCountStore = create<Store>((set, get) => ({
  count: 0,
  actions: {
    increase: () => {
      // const count = get().count;
      // set({
      //   count: count + 1
      // })//프로퍼티값만 업데이트함

      set((store) => ({
        count: store.count + 1,
      }));
    },
    decrease: () => {
      set((store) => ({
        count: store.count - 1,
      }));
    },
  },
}));
actions로 묶어주고

  const {increase, decrease} = useCountStore((store) => store.actions);

이렇게 사용하면된다.
하지만 이런 셀렉터 함수를 컴포넌트 내부에 직접 정의하는 일은 거의 많지 않다.
기능상에 문제는 없지만 유지보수 과정이 어렵기 떄문이다.
그렇기 때문에 스토어가 정의된 파일에서 별도의 커스텀 훅을 만들어서 사용하는게 조금 더 일반적이다.

하지만 store에서 액션함수 increse가 increseOne으로 이름이 바뀌고 decrese가 decreseOne으로 바뀐다면 
  const {increase, decrease} = useCountStore((store) => store.actions);
이거를 불러들이는 컴포넌트가 총 10개 이상이면 하나하나 다 바꿔야 된다 그렇기 때문에 store가 정의도니 파일에서
별도의 커스텀 훅을 만들어서 사용하는게 조금 더 일반적이다.

import { use } from "react";
import { create } from "zustand";

type Store = {
  count: number;
  actions: {
    increase: () => void;
    decrease: () => void;
  };
};

export const useCountStore = create<Store>((set, get) => ({
  count: 0,
  actions: {
    increase: () => {
      // const count = get().count;
      // set({
      //   count: count + 1
      // })//프로퍼티값만 업데이트함

      set((store) => ({
        count: store.count + 1,
      }));
    },
    decrease: () => {
      set((store) => ({
        count: store.count - 1,
      }));
    },
  },
}));

//커스텀 훅
export const useCount = ()=>{
  const count = useCountStore((store) => store.count);
  return count;
}

export const useIncreseCount = ()=>{
  const increase = useCountStore((store) => store.actions.increase);
  return increase;
}

export const useDecreaseCount = ()=>{
  const decrease = useCountStore((store) => store.actions.decrease);
  return decrease;
}

사용하기(컴포넌트)
import { useDecreaseCount, useIncreseCount } from "@/store/count";
import { Button } from "../ui/button";

export default function Controller() {
  const increase = useIncreseCount();
  const decrease = useDecreaseCount();
  return (
    <div>
      <Button onClick={decrease}>-</Button>
      <Button onClick={increase}>+</Button>
    </div>
  );
}

Middleware란?
중간에 있는 도구
회원가입로직에서 로그출력, 중복확인 이런게 미들웨어이다.

combine: Store의 타입을 자동 추론
immer: Store 내부의 상태 업데이트를 보다 편리하게 바꿈
subscribeWithSelector: Store 내의 특정 값 변화시, 이벤트 핸들러 호출
persist: Store를 로컬, 세션 스토리지 등에 보관함
devtools: Store의 값을 개발자 도구에서 확인할 수 있음

import { use } from "react";
import { create } from "zustand";
import { combine } from "zustand/middleware";

// type Store = {
//   count: number;
//   actions: {
//     increase: () => void;
//     decrease: () => void;
//   };
// };

//combine은 자동으로 인수인 count값에 타입을 추론함
//메서드도 타입이 추론이 잘됨
// 주의할점 : 기본적으로 현재 스토어의 타입을 첫번째 인수로 전달한 
//state 값만 포함하는 타입으로 추론한다.
// 하지만 타입만 추론할뿐 get().action.increseOne()함수를
// 호출한다고해서 런타임 에러가 발생하지 않는다.
// 그래서 그냥 추론된 타입대로 현재 state의 값만 포함하는 객체 타입이 들어온다
// 라고 생각해도 된다.
 //오해하지 않게 combine을 사용할때는 메소드에 인자값을 store라 하지 않고
 //state라고 하는게 더 낫다.
export const useCountStore = create(
  combine({ count: 0 }, (set, get) => ({
    actions: {
      increaseOne: () => {
        get(); //타입추론됨
        set((state) => ({
          count: state.count + 1,
        }));
      },
      decreaseOne: () => {
        set((state) => ({
          count: state.count - 1,
        }));
      },
    },
  })),
);

// export const useCountStore = create<Store>((set, get) => ({
//   count: 0,
//   actions: {
//     increase: () => {
//       // const count = get().count;
//       // set({
//       //   count: count + 1
//       // })//프로퍼티값만 업데이트함

//       set((store) => ({
//         count: store.count + 1,
//       }));
//     },
//     decrease: () => {
//       set((store) => ({
//         count: store.count - 1,
//       }));
//     },
//   },
// }));

//커스텀 훅
export const useCount = ()=>{
  const count = useCountStore((store) => store.count);
  return count;
}

export const useIncreseCount = ()=>{
  const increase = useCountStore((store) => store.actions.increase);
  return increase;
}

export const useDecreaseCount = ()=>{
  const decrease = useCountStore((store) => store.actions.decrease);
  return decrease;
}






