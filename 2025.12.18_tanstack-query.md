# TanStack Query 완전 가이드

React에서 서버 데이터를 쉽게 관리하는 라이브러리. 데이터 가져오기, 캐싱, 자동 갱신을 알아서 해준다.

---

## 1. 초기 설정

### 설치

```bash
npm install @tanstack/react-query
npm install @tanstack/react-query-devtools  # 개발 도구 (선택)
```

### main.tsx 설정

```tsx
import { QueryClientProvider, QueryClient } from '@tanstack/react-query'
import { ReactQueryDevtools } from "@tanstack/react-query-devtools"

// QueryClient = 캐시 저장소
const queryClient = new QueryClient();

createRoot(document.getElementById("root")!).render(
  <QueryClientProvider client={queryClient}>
    <ReactQueryDevtools />
    <App />
  </QueryClientProvider>
);
```

---

## 2. useQuery - 데이터 조회

### TanStack Query 없이 구현하면?

```tsx
// 직접 구현 - 상태 관리가 번거롭다
const [todos, setTodos] = useState<Todo[]>([]);
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState();

useEffect(() => {
  setIsLoading(true);
  fetchTodos()
    .then(setTodos)
    .catch(setError)
    .finally(() => setIsLoading(false));
}, []);
```

### useQuery로 간단하게

```tsx
function TodoListPage() {
  const { data: todos, isLoading, error } = useQuery({
    queryKey: ["todos"],   // 캐시 키 (고유 식별자)
    queryFn: fetchTodos,   // 실제 fetch 함수
  });

  if (isLoading) return <div>로딩 중...</div>;
  if (error) return <div>에러: {error.message}</div>;

  return (
    <ul>
      {todos?.map(todo => <li key={todo.id}>{todo.content}</li>)}
    </ul>
  );
}
```

### 주요 옵션

```tsx
const { data, isLoading, refetch } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  
  retry: 3,                    // 실패 시 재시도 횟수
  staleTime: 5000,             // 5초간 fresh 상태 유지
  gcTime: 300000,              // 5분 후 캐시 삭제
  enabled: true,               // false면 자동 fetch 안함
  refetchOnWindowFocus: true,  // 탭 포커스 시 리페칭
});
```

### isPending vs isLoading

| 상태 | 의미 | 언제 사용? |
|------|------|-----------|
| `isPending` | 캐시에 데이터 없음 | 데이터 존재 여부만 체크 |
| `isFetching` | 지금 fetch 중 | 백그라운드 갱신 표시 |
| `isLoading` | `isPending && isFetching` | 첫 로딩 UI 표시 |

```tsx
// 첫 로딩 → 스켈레톤
if (isLoading) return <Skeleton />;

// 캐시 있고 백그라운드 갱신 중 → 작은 스피너
return (
  <div>
    {isFetching && <SmallSpinner />}
    {data?.map(todo => <TodoItem {...todo} />)}
  </div>
);
```

**핵심**: `isLoading`은 처음 데이터 가져올 때만 true. 캐시 있으면 false.

---

## 3. 캐싱 동작 원리

### 데이터 상태 흐름

```
fetching → fresh → stale → inactive → deleted
                ↑
          staleTime 경과
```

### Fresh vs Stale

| 상태 | 의미 | 리페칭 |
|------|------|--------|
| Fresh | 신선한 데이터 | 안 함 |
| Stale | 오래된 데이터 | 특정 조건에서 함 |

```tsx
const { data } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  staleTime: 1000 * 60 * 5,  // 5분간 fresh 유지
});
```

### Stale 데이터도 유용하다

페이지 이동 후 돌아왔을 때:
1. 이전 데이터 즉시 표시 (로딩 없음)
2. 백그라운드에서 새 데이터 가져옴
3. 자동으로 갱신

### Active vs Inactive

| 상태 | 의미 |
|------|------|
| Active | 화면에 해당 쿼리 사용하는 컴포넌트 있음 |
| Inactive | 해당 컴포넌트 없음 (다른 페이지로 이동) |

`gcTime` 경과 후 inactive 캐시는 메모리에서 삭제됨.

---

## 4. 리페칭 타이밍

**Stale 상태일 때만** 리페칭 발생:

| 타이밍 | 설명 | 옵션 |
|--------|------|------|
| Mount | 컴포넌트 등장 시 | `refetchOnMount` |
| WindowFocus | 탭 다시 클릭 | `refetchOnWindowFocus` |
| Reconnect | 인터넷 재연결 | `refetchOnReconnect` |
| Interval | 주기적 자동 | `refetchInterval` |

---

## 5. Query Key 설계

### 계층적 구조

```tsx
const QUERY_KEYS = {
  todos: {
    all: ['todos'] as const,
    list: () => [...QUERY_KEYS.todos.all, 'list'] as const,
    detail: (id: string) => [...QUERY_KEYS.todos.all, 'detail', id] as const,
  }
};
```

### 왜 이렇게 설계할까?

**선택적 캐시 무효화**가 가능해진다:

```tsx
// 'todos'로 시작하는 모든 쿼리 무효화
queryClient.invalidateQueries({ queryKey: ['todos'] });
// → ['todos'], ['todos', 'list'], ['todos', 'detail', '1'] 전부 무효화

// 특정 상세만 무효화
queryClient.invalidateQueries({ queryKey: ['todos', 'detail', '1'] });
// → 이것만 무효화
```

---

## 6. useMutation - 데이터 변경

### 기본 사용법

```tsx
function TodoEditor() {
  const { mutate, isPending } = useMutation({
    mutationFn: createTodo,
  });

  return (
    <button onClick={() => mutate("새 할 일")} disabled={isPending}>
      {isPending ? "추가 중..." : "추가"}
    </button>
  );
}
```

### 콜백 순서

```tsx
const { mutate } = useMutation({
  mutationFn: createTodo,
  
  onMutate: (variables) => {
    // 1. mutate() 호출 직후, API 요청 전
  },
  
  onSuccess: (data, variables) => {
    // 2. 성공 시
  },
  
  onError: (error, variables) => {
    // 2. 실패 시
  },
  
  onSettled: () => {
    // 3. 성공/실패 상관없이 마지막에 실행
  },
});
```

---

## 7. 캐시 무효화 vs 직접 업데이트

데이터 변경 후 화면을 갱신하는 방법은 2가지:

### 방법 1: invalidateQueries (캐시 무효화)

```tsx
useMutation({
  mutationFn: createTodo,
  onSuccess: () => {
    // 캐시 무효화 → 서버에서 다시 가져옴
    queryClient.invalidateQueries({ queryKey: ['todos'] });
  },
});
```

**장점**: 서버 데이터와 확실히 동기화
**단점**: 네트워크 요청 한 번 더 발생

### 방법 2: setQueryData (직접 캐시 수정)

```tsx
useMutation({
  mutationFn: createTodo,
  onSuccess: (newTodo) => {
    // 서버 응답값으로 캐시 직접 수정
    queryClient.setQueryData<Todo[]>(['todos'], (prevTodos) => {
      if (!prevTodos) return [newTodo];
      return [...prevTodos, newTodo];
    });
  },
});
```

**장점**: 추가 네트워크 요청 없음, 즉시 반영
**단점**: 서버와 불일치 가능성 (드물지만)

### onSuccess의 인자값 활용

`mutationFn`의 반환값이 `onSuccess`의 첫 번째 인자로 들어온다:

```tsx
// API 함수
async function createTodo(content: string): Promise<Todo> {
  const response = await fetch('/todos', { ... });
  return response.json();  // 이 반환값이
}

// Mutation
useMutation({
  mutationFn: createTodo,
  onSuccess: (newTodo) => {  // 여기로 들어옴 (타입 추론도 됨!)
    queryClient.setQueryData<Todo[]>(['todos'], (prev) => {
      return prev ? [...prev, newTodo] : [newTodo];
    });
  },
});
```

---

## 8. 낙관적 업데이트 (Optimistic Update)

### 개념

**서버 응답 기다리지 않고** UI를 먼저 업데이트하는 기법.

```
일반적인 흐름:  요청 → 대기 → 응답 → UI 업데이트
낙관적 업데이트: 요청 → UI 즉시 업데이트 → 응답 확인
```

### 왜 사용할까?

SNS의 좋아요 버튼을 생각해보자:
- 하트 클릭 → 서버 응답 기다림 → 하트 채워짐 (느림)
- 하트 클릭 → 즉시 하트 채워짐 → 서버에서 확인 (빠름!)

사용자에게 **즉각적인 반응**을 제공할 수 있다.

### 구현 방법 1: setQueryData 활용 (간단)

서버 응답값을 신뢰할 수 있다면 이 방법이 간단하다:

```tsx
export function useCreateTodoMutation() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: createTodo,
    onSuccess: (newTodo) => {
      // 서버가 반환한 데이터로 캐시 직접 수정
      queryClient.setQueryData<Todo[]>(['todos'], (prevTodos) => {
        if (!prevTodos) return [newTodo];
        return [...prevTodos, newTodo];
      });
    },
    onError: (error) => {
      alert("할 일 추가 실패: " + error);
    },
  });
}
```

### 구현 방법 2: onMutate + 롤백 (완전한 낙관적 업데이트)

요청 **전에** UI를 먼저 바꾸고, 실패하면 롤백:

```tsx
const mutation = useMutation({
  mutationFn: updateTodo,
  
  onMutate: async (newTodo) => {
    // 1. 진행 중인 쿼리 취소 (충돌 방지)
    await queryClient.cancelQueries({ queryKey: ['todos'] });

    // 2. 현재 데이터 백업 (롤백용)
    const previousTodos = queryClient.getQueryData(['todos']);

    // 3. UI 먼저 업데이트 (낙관적!)
    queryClient.setQueryData(['todos'], (old: Todo[]) => 
      old.map(todo => todo.id === newTodo.id ? newTodo : todo)
    );

    // 4. 백업 데이터 반환
    return { previousTodos };
  },

  onError: (err, newTodo, context) => {
    // 실패하면 백업으로 롤백
    queryClient.setQueryData(['todos'], context?.previousTodos);
  },

  onSettled: () => {
    // 마지막에 서버와 동기화
    queryClient.invalidateQueries({ queryKey: ['todos'] });
  },
});
```

### 언제 어떤 방법을 쓸까?

| 상황 | 추천 방법 |
|------|----------|
| 생성(POST) 후 목록 갱신 | setQueryData + onSuccess |
| 좋아요, 토글 같은 즉각 반응 | onMutate + 롤백 |
| 데이터 정합성이 중요 | invalidateQueries |

---

## 9. 커스텀 훅으로 정리

### 조회 훅

```tsx
export function useTodosQuery() {
  return useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    staleTime: 1000 * 60,
  });
}

export function useTodoDetailQuery(id: string) {
  return useQuery({
    queryKey: ['todos', 'detail', id],
    queryFn: () => fetchTodoById(id),
    enabled: !!id,  // id 있을 때만 실행
  });
}
```

### 변경 훅

```tsx
export function useCreateTodo() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: createTodo,
    onSuccess: (newTodo) => {
      queryClient.setQueryData<Todo[]>(['todos'], (prev) => 
        prev ? [...prev, newTodo] : [newTodo]
      );
    },
  });
}

export function useDeleteTodo() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: deleteTodo,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });
}
```

---

## 10. 자주 쓰는 패턴

### 의존적 쿼리

첫 번째 쿼리 결과로 두 번째 쿼리 실행:

```tsx
const { data: user } = useQuery({
  queryKey: ['user'],
  queryFn: getUser,
});

const { data: posts } = useQuery({
  queryKey: ['posts', user?.id],
  queryFn: () => getPostsByUser(user!.id),
  enabled: !!user?.id,  // user 있을 때만!
});
```

### 병렬 쿼리

여러 쿼리 동시 실행:

```tsx
const results = useQueries({
  queries: [
    { queryKey: ['users'], queryFn: fetchUsers },
    { queryKey: ['todos'], queryFn: fetchTodos },
  ]
});
```

### 무한 스크롤

```tsx
const { data, fetchNextPage, hasNextPage } = useInfiniteQuery({
  queryKey: ['posts'],
  queryFn: ({ pageParam }) => fetchPosts(pageParam),
  initialPageParam: 0,
  getNextPageParam: (lastPage) => lastPage.nextCursor,
});
```

---

## 11. v5 주요 변경사항

| v4 | v5 |
|----|----|
| `cacheTime` | `gcTime` |
| `isLoading` | `isPending` |
| `useQuery(key, fn)` | `useQuery({ queryKey, queryFn })` |

---

## 12. 핵심 요약

| 개념 | 설명 |
|------|------|
| **QueryClient** | 캐시 저장소 |
| **queryKey** | 캐시 식별자 |
| **staleTime** | fresh 유지 시간 |
| **gcTime** | 캐시 삭제까지 시간 |
| **invalidateQueries** | 캐시 무효화 → 리페칭 |
| **setQueryData** | 캐시 직접 수정 |
| **낙관적 업데이트** | 서버 응답 전 UI 선반영 |

### TanStack Query를 쓰는 이유

1. **자동 캐싱** - 중복 요청 방지
2. **자동 리페칭** - 데이터 신선도 유지
3. **상태 관리 자동화** - loading, error 알아서 관리
4. **개발 편의** - DevTools로 캐시 상태 확인
