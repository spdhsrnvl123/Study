# TanStack Query 완전 가이드

React 애플리케이션에서 서버 상태 관리를 위한 라이브러리. 데이터 fetching, caching, 동기화, 업데이트를 쉽게 처리할 수 있다.

---

## 1. 초기 설정

### 설치

```bash
npm install @tanstack/react-query
npm install @tanstack/react-query-devtools  # 개발 도구 (선택)
```

### main.tsx 설정

```tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { BrowserRouter } from "react-router"
import { QueryClientProvider, QueryClient } from '@tanstack/react-query'
import { ReactQueryDevtools } from "@tanstack/react-query-devtools"
import App from './App.tsx'
import './index.css'

// QueryClient = 캐시 저장소 (API 응답, 캐시 상태 등 관리)
const queryClient = new QueryClient();

createRoot(document.getElementById("root")!).render(
  <BrowserRouter>
    <QueryClientProvider client={queryClient}>
      <ReactQueryDevtools />  {/* 개발 도구 - 캐시 상태 시각화 */}
      <App />
    </QueryClientProvider>
  </BrowserRouter>,
);
```

---

## 2. useQuery - 데이터 조회

### TanStack Query 없이 구현하면?

```tsx
// 직접 구현 시 - isLoading, error 상태를 일일이 관리해야 함
const [todos, setTodos] = useState<Todo[]>([]);
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState();

const fetchData = async () => {
  setIsLoading(true);
  try {
    const data = await fetchTodos();
    setTodos(data);
  } catch (err) {
    setError(err as any);
  } finally {
    setIsLoading(false);
  }
}

useEffect(() => {
  fetchData();
}, []);
```

### useQuery로 간단하게

```tsx
import { useQuery } from '@tanstack/react-query';

async function fetchTodos() {
  const response = await fetch(`${API_URL}/todos`);
  if (!response.ok) throw new Error("Failed to fetch todos");
  return response.json();
}

function TodoListPage() {
  const { data: todos, isLoading, error } = useQuery({
    queryKey: ["todos"],        // 캐시 키 (고유 식별자)
    queryFn: fetchTodos,        // 실제 fetch 함수
  });

  if (isLoading) return <div>로딩 중...</div>;
  if (error) return <div>에러 발생: {error.message}</div>;

  return (
    <ul>
      {todos?.map(todo => <li key={todo.id}>{todo.content}</li>)}
    </ul>
  );
}
```

### useQuery 주요 옵션

```tsx
const { data, isPending, isLoading, error, refetch, isFetching } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  
  // 재시도 설정
  retry: 3,                    // 실패 시 재시도 횟수 (기본값: 3)
  retry: false,                // 재시도 안함
  
  // 캐시 관련
  staleTime: 5000,             // 5초 동안 fresh 상태 유지
  gcTime: 300000,              // 5분 후 inactive 캐시 삭제 (구 cacheTime)
  
  // 리페칭 조건
  refetchOnMount: true,        // 컴포넌트 마운트 시 (기본: true)
  refetchOnWindowFocus: true,  // 브라우저 탭 포커스 시 (기본: true)
  refetchOnReconnect: true,    // 네트워크 재연결 시 (기본: true)
  refetchInterval: 5000,       // 5초마다 자동 리페칭
  
  // 기타
  enabled: true,               // false면 자동 fetch 안함
  select: (data) => data.filter(t => !t.isDone),  // 데이터 변환
});
```

### isPending vs isLoading (v5 변경점)

v5에서 로딩 상태 관련 명칭이 정리되었다.

| 상태 | 조건 | 용도 |
|------|------|------|
| **isPending** | 데이터가 없는 상태 | 캐시 존재 여부만 체크 |
| **isFetching** | 현재 fetch 진행 중 | 백그라운드 리페칭 포함 |
| **isLoading** | `isPending && isFetching` | 첫 로딩 시에만 true |

```tsx
function TodoList() {
  const { data, isPending, isFetching, isLoading } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  });

  // 첫 로딩 - 스켈레톤 UI 표시
  if (isLoading) return <Skeleton />;

  // 캐시는 있지만 백그라운드에서 갱신 중 - 작은 인디케이터만 표시
  return (
    <div>
      {isFetching && <SmallSpinner />}
      {data?.map(todo => <TodoItem key={todo.id} {...todo} />)}
    </div>
  );
}
```

**핵심**: `isLoading`은 "처음 데이터 가져올 때"만 true. 캐시 있으면 false.

---

## 3. 캐싱 메커니즘 (핵심 개념)

### 데이터 상태 흐름

```
fetching → fresh → stale → (inactive) → deleted
                     ↑
              staleTime 경과
```

### Fresh vs Stale

| 상태 | 설명 | 리페칭 |
|------|------|--------|
| **Fresh** | 데이터가 신선한 상태 | 리페칭 안함 |
| **Stale** | 데이터가 오래된 상태 | 특정 조건에서 리페칭 |

```tsx
// staleTime = 0 (기본값) → 즉시 stale 상태
// staleTime = 5000 → 5초 동안 fresh 유지

const { data } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  staleTime: 1000 * 60 * 5,  // 5분간 fresh
});
```

### Stale 데이터도 유용하다

페이지 이동 후 돌아왔을 때 로딩 화면 대신 stale 데이터를 먼저 보여주고, 백그라운드에서 새 데이터를 가져온다.

```
사용자 경험: 즉시 이전 데이터 표시 → 자동으로 최신 데이터로 갱신
```

### Inactive와 Garbage Collection

```tsx
const { data } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  gcTime: 1000 * 60 * 5,  // 5분 (기본값)
});
```

| 상태 | 설명 |
|------|------|
| **Active** | 해당 캐시를 사용하는 컴포넌트가 마운트됨 |
| **Inactive** | 해당 캐시를 사용하는 컴포넌트가 없음 |
| **Deleted** | gcTime 경과 후 메모리에서 완전 삭제 |

**핵심**: staleTime은 "언제 리페칭할지", gcTime은 "언제 메모리에서 삭제할지"

---

## 4. 리페칭 타이밍 (4가지)

**Stale 상태일 때만** 아래 조건에서 리페칭 발생:

| 타이밍 | 설명 | 옵션 |
|--------|------|------|
| **Mount** | 컴포넌트 마운트 시 | `refetchOnMount` |
| **WindowFocus** | 브라우저 탭 다시 포커스 | `refetchOnWindowFocus` |
| **Reconnect** | 네트워크 재연결 | `refetchOnReconnect` |
| **Interval** | 주기적 자동 | `refetchInterval` |

```tsx
// 모든 자동 리페칭 비활성화
const { data } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  refetchOnMount: false,
  refetchOnWindowFocus: false,
  refetchOnReconnect: false,
});
```

---

## 5. Query Key 설계

### 계층적 구조의 이점

```tsx
// 좋은 예 - 계층적 구조 + as const로 타입 추론 강화
const QUERY_KEYS = {
  todos: {
    all: ['todos'] as const,
    lists: () => [...QUERY_KEYS.todos.all, 'list'] as const,
    list: (filters: string) => [...QUERY_KEYS.todos.all, 'list', filters] as const,
    details: () => [...QUERY_KEYS.todos.all, 'detail'] as const,
    detail: (id: string) => [...QUERY_KEYS.todos.all, 'detail', id] as const,
  }
};

// 사용
useQuery({ queryKey: QUERY_KEYS.todos.all, ... });
useQuery({ queryKey: QUERY_KEYS.todos.detail('1'), ... });
```

### 왜 이렇게 설계할까?

**선택적 캐시 무효화**가 가능해진다:

```tsx
// 'todos'로 시작하는 모든 쿼리 무효화
queryClient.invalidateQueries({ queryKey: ['todos'] });
// → ['todos'], ['todos', 'list'], ['todos', 'detail', '1'] 모두 무효화

// 특정 상세만 무효화
queryClient.invalidateQueries({ queryKey: ['todos', 'detail', '1'] });
// → ['todos', 'detail', '1']만 무효화
```

### 안티패턴

```tsx
// 나쁜 예 - 관계 파악 불가
const keys = {
  list: ['todoList'],
  detail: (id) => ['todoDetail', id],
};
// ['todoList']와 ['todoDetail', '1']은 완전히 별개
// 한 번에 무효화 불가능!
```

---

## 6. useMutation - 데이터 변경

### 기본 사용법

```tsx
import { useMutation } from '@tanstack/react-query';

async function createTodo(content: string) {
  const response = await fetch(`${API_URL}/todos`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ content, isDone: false })
  });
  if (!response.ok) throw new Error("Failed to create todo");
  return response.json();
}

function TodoEditor() {
  const { mutate, isPending, isError, error } = useMutation({
    mutationFn: createTodo,
  });

  const handleSubmit = () => {
    mutate("새로운 할 일");
  };

  return (
    <button onClick={handleSubmit} disabled={isPending}>
      {isPending ? "추가 중..." : "추가"}
    </button>
  );
}
```

### Mutation 콜백

```tsx
const { mutate } = useMutation({
  mutationFn: createTodo,
  
  onMutate: (variables) => {
    // mutate 호출 직후, API 요청 전
    // Optimistic Update에 활용
    console.log("요청 시작:", variables);
  },
  
  onSuccess: (data, variables, context) => {
    // 성공 시
    console.log("성공:", data);
  },
  
  onError: (error, variables, context) => {
    // 실패 시
    console.error("실패:", error.message);
  },
  
  onSettled: (data, error, variables, context) => {
    // 성공/실패 상관없이 완료 후
    console.log("완료");
  },
});
```

---

## 7. 캐시 무효화 (invalidateQueries)

### 기본 패턴

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query';

function useCreateTodoMutation() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createTodo,
    onSuccess: () => {
      // todos 관련 모든 캐시 무효화 → 자동 리페칭
      queryClient.invalidateQueries({ queryKey: ["todos"] });
    },
    onError: (error) => {
      alert("할 일 추가 실패: " + error.message);
    },
  });
}
```

### 무효화 전략

```tsx
// 1. 특정 키 무효화
queryClient.invalidateQueries({ queryKey: ['todos', 'list'] });

// 2. 프리픽스로 시작하는 모든 키 무효화
queryClient.invalidateQueries({ queryKey: ['todos'] });

// 3. 정확히 일치하는 키만 무효화
queryClient.invalidateQueries({ 
  queryKey: ['todos', 'list'],
  exact: true 
});

// 4. 조건부 무효화
queryClient.invalidateQueries({
  predicate: (query) => query.queryKey[0] === 'todos'
});
```

---

## 8. Optimistic Update (낙관적 업데이트)

서버 응답 전에 UI를 먼저 업데이트하고, 실패하면 롤백.

```tsx
const queryClient = useQueryClient();

const mutation = useMutation({
  mutationFn: updateTodo,
  
  onMutate: async (newTodo) => {
    // 1. 진행 중인 쿼리 취소 (낙관적 업데이트 덮어쓰기 방지)
    await queryClient.cancelQueries({ queryKey: ['todos'] });

    // 2. 이전 데이터 스냅샷
    const previousTodos = queryClient.getQueryData(['todos']);

    // 3. 낙관적으로 캐시 업데이트
    queryClient.setQueryData(['todos'], (old: Todo[]) => 
      old.map(todo => todo.id === newTodo.id ? newTodo : todo)
    );

    // 4. 롤백용 컨텍스트 반환
    return { previousTodos };
  },

  onError: (err, newTodo, context) => {
    // 실패 시 롤백
    queryClient.setQueryData(['todos'], context?.previousTodos);
  },

  onSettled: () => {
    // 성공/실패 후 서버와 동기화
    queryClient.invalidateQueries({ queryKey: ['todos'] });
  },
});
```

---

## 9. 커스텀 훅으로 정리

### 조회 훅

```tsx
// hooks/useTodosQuery.ts
import { useQuery } from '@tanstack/react-query';

export function useTodosQuery() {
  return useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    staleTime: 1000 * 60,  // 1분
  });
}

export function useTodoDetailQuery(id: string) {
  return useQuery({
    queryKey: ['todos', 'detail', id],
    queryFn: () => fetchTodoById(id),
    enabled: !!id,  // id 있을 때만 실행
  });
}
```

### 변경 훅

```tsx
// hooks/useTodoMutations.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';

export function useCreateTodo() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: createTodo,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });
}

export function useUpdateTodo() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: updateTodo,
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['todos', 'detail', id] });
      queryClient.invalidateQueries({ queryKey: ['todos', 'list'] });
    },
  });
}

export function useDeleteTodo() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: deleteTodo,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });
}
```

---

## 10. DevTools 활용

```tsx
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

// QueryClientProvider 내부에 추가
<QueryClientProvider client={queryClient}>
  <ReactQueryDevtools initialIsOpen={false} />
  <App />
</QueryClientProvider>
```

**확인할 수 있는 것들:**
- 모든 쿼리의 상태 (fresh/stale/fetching/inactive)
- 캐시된 데이터 내용
- 쿼리 키 구조
- 리페칭 타이밍

---

## 11. 자주 쓰는 패턴 정리

### 의존적 쿼리 (Dependent Queries)

```tsx
// 첫 번째 쿼리 결과에 따라 두 번째 쿼리 실행
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
});

const { data: projects } = useQuery({
  queryKey: ['projects', user?.id],
  queryFn: () => getProjectsByUser(user!.id),
  enabled: !!user?.id,  // user 있을 때만 실행
});
```

### 병렬 쿼리 (Parallel Queries)

```tsx
// 동시에 여러 쿼리 실행
const results = useQueries({
  queries: [
    { queryKey: ['users'], queryFn: fetchUsers },
    { queryKey: ['todos'], queryFn: fetchTodos },
    { queryKey: ['posts'], queryFn: fetchPosts },
  ]
});
```

### 무한 스크롤 (Infinite Queries)

```tsx
import { useInfiniteQuery } from '@tanstack/react-query';

const { data, fetchNextPage, hasNextPage, isFetchingNextPage } = useInfiniteQuery({
  queryKey: ['posts'],
  queryFn: ({ pageParam }) => fetchPosts(pageParam),
  initialPageParam: 0,  // v5 필수! 없으면 에러
  getNextPageParam: (lastPage) => lastPage.nextCursor,
});
```

---

## 12. v5 주요 변경사항

v4에서 v5로 업그레이드할 때 알아야 할 핵심 변경점:

| v4 | v5 | 비고 |
|----|----|----|
| `cacheTime` | `gcTime` | 명칭 변경 |
| `isLoading` (메인) | `isPending` | 로딩 상태 분리 |
| `isInitialLoading` | `isLoading` | = isPending && isFetching |
| `useQuery(key, fn)` | `useQuery({ queryKey, queryFn })` | 객체 형태 필수 |
| `initialPageParam` 선택 | `initialPageParam` 필수 | useInfiniteQuery |
| 에러 타입 `unknown` | 에러 타입 `Error` | TypeScript |

```tsx
// v4 (구버전)
const { data, isLoading } = useQuery(['todos'], fetchTodos);

// v5 (현재)
const { data, isPending } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
});
```

---

## 13. 핵심 요약

| 개념 | 설명 |
|------|------|
| **QueryClient** | 캐시 저장소 |
| **queryKey** | 캐시 식별자 (배열, 계층적 설계) |
| **queryFn** | 실제 데이터 fetch 함수 |
| **staleTime** | fresh → stale 전환 시간 |
| **gcTime** | inactive → deleted 전환 시간 |
| **invalidateQueries** | 캐시 무효화 → 리페칭 트리거 |
| **Optimistic Update** | 서버 응답 전 UI 선반영 |

### TanStack Query 사용 이유

1. **자동 캐싱** - 같은 데이터 중복 요청 방지
2. **자동 리페칭** - 데이터 신선도 유지
3. **상태 관리 자동화** - loading, error 상태 자동 관리
4. **데이터 동기화** - 서버와 클라이언트 상태 일치
5. **개발자 경험** - DevTools로 디버깅 용이
