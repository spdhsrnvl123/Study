json-server

import { API_URL } from "@/lib/constants";

export async function createTodo(){
  const response = await fetch(`${API_URL}/todos`,{
    method: "POST",
    body: JSON.stringify({
      id,
      content,
      isDone
    })
  }
}

이렇게 넘겨주면 Json-server는 id값을 문자열로 만들어준다.
그리고 굳이 id값을 안넣어도 된다.
버전 업데이트 하면서 랜덤으로 문자열 값이 만들어진다. id값이...

mutation사용법
createTodo함수를 직접 호출 하면 되지 않나? 생각할 수도 있는데 왜 굳이 useMutation을 사용하냐면 해당 함수의
상태값을 관리하기 위해서이다.

  const {mutate, isPending} = useMutation({
    mutationFn: createTodo
  })

mutate는 함수호출처럼 사용하면된다.
isPending은 mutate로 호출한 함수의 비동기 요청의 로딩 상태를 파악할 수 있다.

mutate에 옵션은 4가지가 있다.
onMutate, onSettled, onSuccess, OnError가 있다.

onSuccess: 성공했을때 실행할 로직
onError: 실패했을때 실행할 로직 

export function useCreateTodoMutation() {
  return useMutation({
    mutationFn: createTodo,
    onMutate: () => {},
    onSettled: () => {},
    onSuccess: () => {
      window.location.reload();
    },
    onError: (error) => {
      window.alert("할 일 추가 중 오류가 발생했습니다: " + error);
    },
  });

  캐시데이터 다루기 1 - 캐시 무효화 하기
  invalidateQueries 무효화 메서드
  
import { createTodo } from "@/api/create-todo";
import { useMutation, useQueries, useQueryClient } from "@tanstack/react-query";

export function useCreateTodoMutation() {
  const queryClient = useQueryClient(); //캐시무효화 위해 필요

  return useMutation({
    mutationFn: createTodo,
    onMutate: () => {},
    onSettled: () => {},
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["todos"] }); //캐시무효화
    },
    onError: (error) => {
      window.alert("할 일 추가 중 오류가 발생했습니다: " + error);
    },
  });
}

좋은 질문이에요! TanStack Query의 쿼리 키 구조는 계층적 구조와 캐시 무효화 전략을 위한 거예요.
1. 왜 배열 형태인가?
TanStack Query는 쿼리 키를 배열의 각 요소를 비교해서 캐시를 관리해요.
typescript['todo']                    // 다른 키
['todo', 'list']            // 다른 키
['todo', 'detail', '1']     // 다른 키
배열이 아니면:
typescript'todo'        // 하나의 문자열만 가능
'todoList'    // 완전히 다른 키
'todoDetail1' // 완전히 다른 키
이렇게 되면 관계를 파악하기 어려워요.
2. 왜 'todo'를 중복시키나?
이게 핵심인데, 계층적 무효화(Hierarchical Invalidation) 때문이에요!
typescript// todo 관련 데이터를 만들거나 수정한 후
queryClient.invalidateQueries({ queryKey: ['todo'] });
이렇게 하면 'todo'로 시작하는 모든 쿼리가 무효화돼요:

✅ ['todo']
✅ ['todo', 'list']
✅ ['todo', 'detail', '1']
✅ ['todo', 'detail', '2']

실제 사용 예시
typescript// Todo 생성 후
const createTodoMutation = useMutation({
  mutationFn: createTodo,
  onSuccess: () => {
    // 'todo'로 시작하는 모든 캐시 무효화 → 리스트 자동 refetch
    queryClient.invalidateQueries({ queryKey: ['todo'] });
  }
});

// Todo 수정 후
const updateTodoMutation = useMutation({
  mutationFn: updateTodo,
  onSuccess: (_, id) => {
    // 특정 todo 상세만 무효화
    queryClient.invalidateQueries({ 
      queryKey: ['todo', 'detail', id] 
    });
    // 또는 리스트도 함께 무효화
    queryClient.invalidateQueries({ 
      queryKey: ['todo', 'list'] 
    });
  }
});
3. 구조의 장점
typescriptQuery_KEYS = {
  todo: {
    all: ['todo'],              // 모든 todo 관련 쿼리
    list: ['todo', 'list'],     // todo 목록만
    detail: (id) => ['todo', 'detail', id], // 특정 todo만
  }
}
선택적 무효화 가능:

['todo'] 무효화 → 모든 todo 관련 데이터 갱신
['todo', 'list'] 무효화 → 목록만 갱신
['todo', 'detail', '1'] 무효화 → ID 1번만 갱신

안티패턴 (중복 없이):
typescript// ❌ 나쁜 예
const keys = {
  list: ['todoList'],
  detail: (id) => ['todoDetail', id],
}
// 문제: 하나의 키로 모두 무효화할 수 없음!
이제 왜 'todo'를 반복하는지 이해되셨나요? 공통 prefix로 관련된 쿼리들을 그룹화하는 거예요!


